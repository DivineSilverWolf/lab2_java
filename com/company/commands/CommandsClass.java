package com.company.commands;
import java.util.Stack;
import java.util.TreeMap;
import com.company.constants.ConstantsAbsoluteNames;

/**
 *  Это класс-стандарт для всех команд
 *  Используется для задания характеристик всех производных от него команд.
*/

public abstract class CommandsClass{
    /**
     * У каждой команды есть своё имя, для её вызова command_name,которое добавляется при создании
     * через конструктор.
     * Плюс в том, что мы можем, при необходимости, дополнить программу пользовательскими настройками
     * Например:
     * дефолтная настройка: команда PUSH
     * пользователю она чем-то не нравится и он заменяет на push: PUSH -> push
     * В итоге мы будем искать в тестовом калькуляторе не PUSH, а push.
     * Улучшает понимание кода в целом(!Моё мнение!)
     * А так же позволяет удобно создавать или удалять команды(в обоих смыслах: Создать новую команду
     * в плане расширения функционала калькулятора в целом
     * и создать ту же команду но с другим названием где-то ещё)
     *
     * Сомнительная вещь, как раз таки "одиночная привязка". Если она не нужна можно создать
     * список из названий команд, вместо одной команды, а так же метод позволяющий с ним взаимодействовать.
     * Ну и конечно же поментять метод return_command_name()!
     * Либо вовсе убрать command_name;конструкторы от CommandsClass и его самого;return_command_name.
     *
     * Если что return_command_name() сделан для наследников.
     */
    private String command_name;
    public CommandsClass(String command_name){this.command_name=command_name;}
    public String return_command_name(){return command_name;}
    /**
     * методы command_push и command_define переопределяют только классы Push и Define соответственно
     * В противном случае методы выводят на консоль: "not found"
     */
    public void command_push(Stack<Double> stack, TreeMap<String,Double> define, String push_number){System.out.println("not found");}
    public void command_define(TreeMap<String,Double> define, String variable,String value){System.out.println("not found");}
    /**
     * Метод command является основным и должен определяться в каждом классе команды, за исключением
     * Push и Define, которые переопределят метод, как ничего не делающий. Связано это с тем, что
     * команды этих классов требуют больше данных. Да, можно сделать единый абстрактный метод принимающий
     * все параметры, однако это несёт как плюсы, так и минусы:
     * (!по моему мнению!)
     * Плюсы: мы можем переопределять только один метод, что визуально сокращает код и делает его
     * более однотипным.
     * Минусы: частый ввод ненужных параметров(на данный момент написано 9 команд. Из них нуждаются в параметрах,
     * за исключением параметра Stack<Double> stack,
     * только 2);
     * Ухудшение восприятия кода(когда мы передаём непонятные
     * данные, непонятно как мы их используем, особенно, когда БОЛЬШЕНСТВО ими не пользуются);
     * усложнение обработки калькулятора (Что нужно передавать в параметры String variable,String value,
     * String push_number? Собственно можно передать пустые значения(""), когда мы не трогаем команду
     * Push и Define)
     */

    public abstract void command(Stack<Double> stack);

    /**
     * Так же важный абстрактный метод get_nameClass(). Его можно назвать абсолютным именем нашей
     * команды. Как бы мы не обозвали команду, у неё есть абсолютное название. Если мы не знаем, что за
     * команда была совершена(например бегая по тестовому калькулятору), мы всегда можем понять по
     * абсолютному имени. В классах наследниках от этого класса(CommandsClass)
     * я создал методы Static, что позволяет, не создавая объект команду, проверить абсолютное имя.
     * Будем считать, что get_nameClass как раз вызывает static метод get_className()
    */
    public abstract String get_nameClass();

    /**
     * Метод позволяющий проверить является ли строка числом. Полезно на данный момент только
     * для Define и Push.
     */
    public static boolean isNumeric(String numeric) throws NumberFormatException {
            try {
                Double.parseDouble(numeric);
                return true;
            }
            catch (NumberFormatException e) {
                return false;
            }
    }

}